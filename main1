{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ce02db16-9c44-4174-9c4a-5f5b6b0b2383",
   "metadata": {},
   "source": [
    "<h1>Homework 4</h1>\n",
    "<h2>Part 1</h2>\n",
    "\n",
    "\n",
    "<h3>(a) Match to Jackson and to Johnson </h3>\n",
    "<h4>Answer to question a:</h4>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "3a877c67-328d-4891-853e-caa1365a1e91",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['Jackson', 'Johnson']"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import re\n",
    "\n",
    "mylist = [\"Jackson\", \"Johnson\"]\n",
    "outlist = []\n",
    "\n",
    "for this in mylist:\n",
    "    m = re.findall(r\"J\\w+son\", this)  # Non-capturing group (?:)\n",
    "    outlist += m\n",
    "\n",
    "outlist"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6fac71bc-c001-4747-9c48-ad36f16d7c73",
   "metadata": {},
   "source": [
    "Here, re.findall() searches for all non-overlapping matches of the regex pattern in the current string (this). r\"J\\w+son\" J matches the letter \"J\", \\w+ matches one or more characters, son matches the string \"son\""
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0e30eca9-7d84-418f-afc6-b0a13c9a7135",
   "metadata": {},
   "source": [
    "<h3>(b) Match to Jackson and Johnson, but not to Jason </h3>\n",
    "<h4>Ans to question b: </h4>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "15c4794f-47cc-4b29-8236-ea2b4c03edd1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['Jackson', 'Johnson']"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import re\n",
    "\n",
    "mylist = [\"Jackson\", \"Johnson\", \"Jason\"]\n",
    "outlist = []\n",
    "\n",
    "for this in mylist:\n",
    "    m = re.findall(r\"J(?:ack|ohn)son\", this)  # Non-capturing group (?:)\n",
    "    outlist += m\n",
    "\n",
    "outlist"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "435ab37b-638d-4bd3-9ed9-1c11dd1eae99",
   "metadata": {},
   "source": [
    "Here, re.findall() searches for all non-overlapping matches of the regex pattern in the current string (this).\n",
    "The pattern r\"J(?:ack|ohn)son\" matches names that start with \"J\", followed by either \"ack\" or \"ohn\", and end with \"son\".\n",
    "(?:ack|ohn) is a non-capturing group that matches either \"ack\" or \"ohn\" without storing them separately. This ensures the full match \"Jackson\" or \"Johnson\" is returned."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "90ae8fd4-eba5-4607-bbb4-714ad7b0c38b",
   "metadata": {},
   "source": [
    "<h3>(c) Match to an id of the form NM_123456.2 where the letters at the beginning can be any \n",
    "combination of 2 uppercase letters, the numbers between the _ and the period can be \n",
    "any set of numbers (could be 2 digits, could be 10), and the number after the period can \n",
    "be any single digit.</h3>\n",
    "<h4>Ans to question c: </h4>\n",
    "We need to match an ID with two uppercase letters, followed by an underscore, then a sequence of digits, a period, and a single digit. This pattern captures IDs like NM_123456.2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "40eefd38-ec18-4732-ac17-5e57978e1a12",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matched: ['NM_123456.2', 'SP_6438221.5', 'AC_15.8', 'AB_224.7']\n"
     ]
    }
   ],
   "source": [
    "# Test List\n",
    "id_string = \"NM_123456.2\", \"SP_6438221.5\", \"AC_15.8\", \"AB_224.7\"\n",
    "\n",
    "# Regex pattern\n",
    "pattern = r\"[A-Z]{2}_\\d+\\.\\d\"\n",
    "\n",
    "# Find matches\n",
    "matches = []\n",
    "for id in id_string:\n",
    "    match = re.findall(pattern, id)\n",
    "    if match:\n",
    "        matches += match\n",
    "\n",
    "print(\"Matched:\", matches)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5716ceb6-9657-4146-9a97-75ddfaf518cc",
   "metadata": {},
   "source": [
    "\"id_string\" is a tuple containing multiple strings, so we need to loop over each string in the tuple.\n",
    "Pattern: r\"[A-Z]{2}_\\d{2,10}\\.\\d\"    here, \"[A-Z]{2}\" matches exactly 2 uppercase letters, \"\\d{2,10}\" matches between 2 and 10 digits and \"\\.\\d\" Matches a period followed by a single digit."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bca5e86f-4e7d-4a04-a66c-14f7ce361d0c",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "07f98e1d-351d-42cd-8bf3-002c90b25a4d",
   "metadata": {},
   "source": [
    "<h3> \r\n",
    "d) Match to an id of the form NM_123456.2 or NM_123456 where the letters at the \r\n",
    "beginning can be any combination of 2 uppercase letters, the numbers after the _ can \r\n",
    "be any set of numbers (could be 2 digits, could be 10).  There may or may not be a \r\n",
    "period followed by a single digi the end.t at</h3>\n",
    "<h4>Ans to question d: </hend."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 186,
   "id": "780df6b6-b9f4-4894-bc91-6aef78b60d6c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matched: ['NM_123456.2', 'AB_78910.9', 'XY_12', 'NM_9876543210', 'CD_9876543210.7']\n"
     ]
    }
   ],
   "source": [
    "mylist = \"NM_123456.2\", \"AB_78910.9\", \"XY_12\", \"NM_9876543210\", \"CD_9876543210.7\", \"N_123456\", \"Nm_123456\"\n",
    "\n",
    "# Output list to store the matches\n",
    "outlist = []\n",
    "\n",
    "# Regex pattern\n",
    "pattern = r\"[A-Z]{2}_\\d{2,10}(\\.\\d)?\"\n",
    "\n",
    "# find matches\n",
    "for this in mylist:\n",
    "    match = re.findall(pattern, this)\n",
    "    if match:\n",
    "        outlist.append(this)\n",
    "\n",
    "# Print the matched results\n",
    "print(\"Matched:\", outlist)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "97a9bfcb-ba5f-4a76-a9d0-b780587adaa8",
   "metadata": {},
   "source": [
    "\"mylist\" is a tuple containing multiple strings, so we need to loop over each string in the tuple.\n",
    "Pattern: r\"[A-Z]{2}_\\d{2,10}(\\.\\d)?\"    here, \"[A-Z]{2}\" matches exactly 2 uppercase letters, \"\\d{2,10}\" matches between 2 and 10 digits and \"(\\.\\d)?\" optionally matches a period followed by a single digit <h6>(the ? makes it optional).</h6>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "918922b2-ade3-43b1-be5d-b46977fe8754",
   "metadata": {},
   "source": [
    "<h3>e) A standard 10-digit phone number with some using – as a separator (e.g. 123-456-7890) \r\n",
    "and some will have a dot (.) as a separator (e.g. 123.456.7890)</h3>.\n",
    "\n",
    "<h4>Ans to the question e: </h4> \r\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 190,
   "id": "b991ecd6-1b19-47d6-9577-75f79ebe8a24",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matched: ['123-456-7890', '123.456.7890']\n"
     ]
    }
   ],
   "source": [
    "phone_numbers = \"123-456-7890, 123.456.7890\"\n",
    "\n",
    "# Regex Pattern\n",
    "pattern = r\"\\d{3}[-.]\\d{3}[-.]\\d{4}\"\n",
    "\n",
    "# Find matches\n",
    "matches = re.findall(pattern, phone_numbers)\n",
    "print(\"Matched:\", matches)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "47fed853-4a8e-49ed-84d0-9902ec905855",
   "metadata": {},
   "source": [
    "\"\\d{3}\" matches three digits, \"[-.]\" matches either a hyphen or a dot, \"\\d{4}\" matches the final four digits of the phone number."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "456308c8-b8d4-4665-87ca-5177a31919ad",
   "metadata": {},
   "source": [
    "<h2>Part 2</h2>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c96bc39b-e7f5-4c39-9c5b-24f397fe8e07",
   "metadata": {},
   "source": [
    "<h3> Short answer – write a single re.findall command to capture the data asked for.  \r\n",
    "Samples of input data are given.  Assume the input data are being read in one line at a time, \r\n",
    "into a variable called “linein”.  Pay attention to details, details matter.  Your answers should be \r\n",
    "like: \r\n",
    "m = re.findall(“regex pattern”, linein)</h3>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e638d10-f528-4436-be8c-2e58dc77d644",
   "metadata": {},
   "source": [
    "<h4> (a) Capture the components of the time separately as hours, minutes, and seconds</h4>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 196,
   "id": "39a01af9-471c-4f5a-acc1-2d347f3599ca",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Date: Mon, 14 May 2001 19:36:00 (PDT)\n",
    "#Date: Fri, 7 Aug 2000 12:37:00 (PDT) \n",
    "#Date: Wed, 11 Jan 2001 03:16:00 (PDT)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 198,
   "id": "dec5f0dc-bf95-47c0-a3a5-b4bc81de8d84",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matched: [('19', '36', '00'), ('12', '37', '00'), ('03', '16', '00')]\n"
     ]
    }
   ],
   "source": [
    "times = \"19:36:00, 12:37:00, 03:16:00\"\n",
    "\n",
    "# Regex pattern\n",
    "pattern = r\"(\\d{2}):(\\d{2}):(\\d{2})\"\n",
    "\n",
    "# Find matches\n",
    "matches = re.findall(pattern, times)\n",
    "print(\"Matched:\", matches)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8bf3ddb3-242e-465a-a27b-42d9d0cd73e0",
   "metadata": {},
   "source": [
    "\"(\\d{2})\" captures two digits for hours, minutes, and seconds."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2d8042f2-598d-4d5e-a2ae-34364e1f2aae",
   "metadata": {},
   "source": [
    "<h4>b) Capture the components of the date separately, not including the day of the week (e.g. \r\n",
    "Mon) </h4\n",
    "\n",
    "\n",
    "<ul>\n",
    "  <li>Date: Mon, 14 May 2001 19:36:00 (PDT) </li>\n",
    "  <li>Date: Fri, 7 Aug 2000 12:37:00 (PDT) </li>\n",
    "  <li>Date: Wed, 11 Jan 2001 03:16:00 (PDT) </li>\n",
    "</ul>)          ***2b almost. You needed to capture the components of the date separately i.e. [‘14’, ‘May’, ‘2021’] not ’14 May ...>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 202,
   "id": "97b05bed-dfb1-43c0-91e4-c1ed8d034652",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "14 May 2001\n",
      "7 Aug 2000\n",
      "11 Jan 2001\n"
     ]
    }
   ],
   "source": [
    "dates = [\n",
    "    \"Date: Mon, 14 May 2001 19:36:00 (PDT)\",\n",
    "    \"Date: Fri, 7 Aug 2000 12:37:00 (PDT)\",\n",
    "    \"Date: Wed, 11 Jan 2001 03:16:00 (PDT)\"\n",
    "]\n",
    "\n",
    "#Regex Pattern\n",
    "pattern = r\"\\d{1,2}\\s\\w{3}\\s\\d{4}\"\n",
    "\n",
    "#Looping over the date strings and find matches\n",
    "for date in dates:\n",
    "    match = re.search(pattern, date)\n",
    "    if match:\n",
    "        print(f\"{match.group()}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fb391909-8492-4762-8118-a9367692479a",
   "metadata": {},
   "source": [
    "\"\\d{1,2}\", matches the day (1 or 2 digits), \"\\s\" matches a space, \"\\w{3}\", matches the month, which consists of three letters (e.g., \"May\", \"Jan\"), \"\\s\"matches another space, \"\\d{4}\" matches the year, which consists of four digits."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "202784e1-924e-4b88-b010-e807bd612c4f",
   "metadata": {},
   "source": [
    "<h4>c) Capture the information between the pairs of tags.  There are 2 pairs of tags per line.  A \r\n",
    "pair of tags is like thi <s/h4>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 206,
   "id": "8e7d3508-3fd4-4c3a-b77c-7fefbe2b31e6",
   "metadata": {},
   "outputs": [],
   "source": [
    "#<a> </a> \n",
    "#<b>hello hello 123</b> stuff to ignore here <i>123412bhje</i> \n",
    "#<a>what???</a> stuff to ignore here <b>asd13asf</b> \n",
    "#<i>who! Hooooo!</i> stuff to ignore here <i>df7887a</i> </h4>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 208,
   "id": "f5cf9042-1d57-4f40-837a-d25c776e3560",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "hello hello 123\n",
      "123412bhje\n",
      "what???\n",
      "asd13asf\n",
      "who! Hooooo!\n",
      "df7887a\n"
     ]
    }
   ],
   "source": [
    "text = \"\"\"\n",
    "<b>hello hello 123</b> stuff to ignore here <i>123412bhje</i>\n",
    "<a>what???</a> stuff to ignore here <b>asd13asf</b>\n",
    "<i>who! Hooooo!</i> stuff to ignore here <i>df7887a</i>\n",
    "\"\"\"\n",
    "\n",
    "# Regex pattern\n",
    "pattern = r\"<[a-z]+>(.*?)</[a-z]+>\"\n",
    "\n",
    "# Find all matches in the text\n",
    "matches = re.findall(pattern, text)\n",
    "\n",
    "for match in matches:\n",
    "    print(match)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 210,
   "id": "414b1255-532b-43b8-802f-db6927511195",
   "metadata": {},
   "outputs": [],
   "source": [
    "#\"<[a-z]+>\" matches the opening tag (e.g., <b>, <a>, <i>) by looking for lowercase letters between < and >, \n",
    "# (.*?)\" this part captures everything inside the tags. The \n",
    "# *? is a non-greedy match,\n",
    "# meaning it will capture the shortest match possible between tags, \n",
    "#\"</[a-z]+>\" matches the corresponding closing tag (e.g., </b>, </a>, </i>)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d58aec66-1623-4fe4-8e8e-d0366a95ce6a",
   "metadata": {},
   "source": [
    "<h4>(d) Capture the information associated with each tag, but don’t capture the tag or the \r\n",
    "equals sign.  A tag is like thiserin </h4>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 213,
   "id": "e0011435-dd42-44f9-85d6-28ad692dbc4b",
   "metadata": {},
   "outputs": [],
   "source": [
    "#/xyz= \n",
    "#/gene=apoE /defin=apolipoprotein E \n",
    "#/gene=BIN1 /defin=bridging integrator 1 \n",
    "#/gene=CLU /defin=clusterin"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 215,
   "id": "9d8251e8-daf3-4255-a3e1-018b4236e460",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Captured information: ['apoE', 'apolipoprotein E', 'BIN1', 'bridging integrator 1', 'CLU', 'clusterin']\n"
     ]
    }
   ],
   "source": [
    "text = \"\"\"\n",
    "/gene=apoE /defin=apolipoprotein E\n",
    "/gene=BIN1 /defin=bridging integrator 1\n",
    "/gene=CLU /defin=clusterin\n",
    "\"\"\"\n",
    "pattern = r\"/(?:gene|defin)=([\\w\\s]+)\\s*\"\n",
    "\n",
    "matches = re.findall(pattern, text)\n",
    "matches = [match.strip() for match in matches]\n",
    "\n",
    "print(\"Captured information:\", matches)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7fe93209-222d-45e7-a33b-fca9581a5341",
   "metadata": {},
   "source": [
    "<h4><p>e) Capture the initial id (starts with ENS) and the id that comes after Acc: (not including the Acc:) in lines like these:</p></h4>\r\n",
    "\r\n",
    "<ul>\r\n",
    "  <li>ENSSSCT00005000020.1 [Source:NCBI gene;Acc:100518619]</li>\r\n",
    "  <li>ENSSSCT00005000043.1 [Source:NCBI gene;Acc:100518619]</li>\r\n",
    "  <li>ENSSSCT00005000036.1 [Source:NCBI gene;Acc:100620765]</li>\r\n",
    "  <li>ENSSSCT00005000022.1 [Source:NCBI gene;Acc:100153964]</li>\r\n",
    "</ul>\r\n",
    "\r\n",
    "<p>But not from lines like these:</p>\r\n",
    "\r\n",
    "<ul>\r\n",
    "  <li>ENSSSCT00005066664.1 [Source:RefSeq mRNA;Acc:NM_001285974]</li>\r\n",
    "  <li>ENSSSCG00005039880.1 [Source:RefSeq mRNA;Acc:NM_001285974]</li>\r\n",
    "  <li>ENSSSCG00005000065.1 [Source:NCBI gene;Acc:100627239]</li>\r\n",
    "</ul>\r\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 218,
   "id": "dd0b1f8d-5ba2-4d0e-8069-e9ec69e1fed5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[('ENSSSCT00005000020', '100518619'), ('ENSSSCT00005000043', '100518619'), ('ENSSSCT00005000036', '100620765'), ('ENSSSCT00005000022', '100153964'), ('ENSSSCG00005000065', '100627239')]\n"
     ]
    }
   ],
   "source": [
    "data = \"\"\"\n",
    "ENSSSCT00005000020.1 [Source:NCBI gene;Acc:100518619]\n",
    "ENSSSCT00005000043.1 [Source:NCBI gene;Acc:100518619]\n",
    "ENSSSCT00005000036.1 [Source:NCBI gene;Acc:100620765]\n",
    "ENSSSCT00005000022.1 [Source:NCBI gene;Acc:100153964]\n",
    "ENSSSCT00005066664.1 [Source:RefSeq mRNA;Acc:NM_001285974]\n",
    "ENSSSCG00005039880.1 [Source:RefSeq mRNA;Acc:NM_001285974]\n",
    "ENSSSCG00005000065.1 [Source:NCBI gene;Acc:100627239]\n",
    "\"\"\"\n",
    "\n",
    "# Regex pattern\n",
    "pattern = r\"(ENS\\w+)\\.\\d+.*?Acc:(\\d+)\"\n",
    "\n",
    "# Find matches\n",
    "matches = re.findall(pattern, data)\n",
    "\n",
    "# Display results\n",
    "print( matches)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "532c9183-55c8-4a85-8600-dab23507d64c",
   "metadata": {},
   "source": [
    "\"(ENS\\w+)\\.\\d+\", this captures the initial ID that starts with \"ENS\" followed by word characters (\\w+) and a dot (\\.) followed by digits (\\d+). The parentheses make this a capturing group. \"*?\", this is a non-greedy match to capture any characters between the initial ID and \"Acc:\". \"(\\d+)\" this captures the numeric ID after \"Acc:\", ensuring that only digits are captured (not IDs that start with \"NM_\" or other non-numeric patterns)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ed140b1c-36cc-4bbd-b422-63718b31c362",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
